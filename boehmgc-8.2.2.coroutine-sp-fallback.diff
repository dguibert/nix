diff -u -r gc-8.2.2/darwin_stop_world.c gc-8.2.2.new/darwin_stop_world.c
--- gc-8.2.2/darwin_stop_world.c	2022-08-26 20:44:49.000000000 +0200
+++ gc-8.2.2.new/darwin_stop_world.c	2022-10-03 10:33:31.237390132 +0200
@@ -356,6 +356,7 @@
   int nthreads = 0;
   word total_size = 0;
   mach_msg_type_number_t listcount = (mach_msg_type_number_t)THREAD_TABLE_SZ;
+  size_t stack_limit;
   if (!EXPECT(GC_thr_initialized, TRUE))
     GC_thr_init();
 
@@ -411,6 +412,19 @@
             GC_push_all_stack_sections(lo, hi, p->traced_stack_sect);
           }
           if (altstack_lo) {
+            // When a thread goes into a coroutine, we lose its original sp until
+            // control flow returns to the thread.
+            // While in the coroutine, the sp points outside the thread stack,
+            // so we can detect this and push the entire thread stack instead,
+            // as an approximation.
+            // We assume that the coroutine has similarly added its entire stack.
+            // This could be made accurate by cooperating with the application
+            // via new functions and/or callbacks.
+            stack_limit = pthread_get_stacksize_np(p->id);
+            if (altstack_lo >= altstack_hi || altstack_lo < altstack_hi - stack_limit) { // sp outside stack
+              altstack_lo = altstack_hi - stack_limit;
+            }
+
             total_size += altstack_hi - altstack_lo;
             GC_push_all_stack(altstack_lo, altstack_hi);
           }
Only in gc-8.2.2.new: darwin_stop_world.c.orig
diff -u -r gc-8.2.2/pthread_stop_world.c gc-8.2.2.new/pthread_stop_world.c
--- gc-8.2.2/pthread_stop_world.c	2022-08-26 20:44:49.000000000 +0200
+++ gc-8.2.2.new/pthread_stop_world.c	2022-10-03 10:52:44.055608016 +0200
@@ -780,6 +780,8 @@
     struct GC_traced_stack_sect_s *traced_stack_sect;
     pthread_t self = pthread_self();
     word total_size = 0;
+    size_t stack_limit;
+    pthread_attr_t pattr;
 #   ifdef E2K
       GC_bool is_stopped = (GC_bool)GC_world_is_stopped;
 #   endif
@@ -851,6 +853,31 @@
           hi = p->altstack + p->altstack_size;
           /* FIXME: Need to scan the normal stack too, but how ? */
           /* FIXME: Assume stack grows down */
+        } else {
+          if (pthread_getattr_np(p->id, &pattr)) {
+            ABORT("GC_push_all_stacks: pthread_getattr_np failed!");
+          }
+          if (pthread_attr_getstacksize(&pattr, &stack_limit)) {
+            ABORT("GC_push_all_stacks: pthread_attr_getstacksize failed!");
+          }
+          if (pthread_attr_destroy(&pattr)) {
+            ABORT("GC_push_all_stacks: pthread_attr_destroy failed!");
+          }
+          // When a thread goes into a coroutine, we lose its original sp until
+          // control flow returns to the thread.
+          // While in the coroutine, the sp points outside the thread stack,
+          // so we can detect this and push the entire thread stack instead,
+          // as an approximation.
+          // We assume that the coroutine has similarly added its entire stack.
+          // This could be made accurate by cooperating with the application
+          // via new functions and/or callbacks.
+          #ifndef STACK_GROWS_UP
+            if (lo >= hi || lo < hi - stack_limit) { // sp outside stack
+              lo = hi - stack_limit;
+            }
+          #else
+          #error "STACK_GROWS_UP not supported in boost_coroutine2 (as of june 2021), so we don't support it in Nix."
+          #endif
         }
         GC_push_all_stack_sections(lo, hi, traced_stack_sect);
 #       ifdef STACK_GROWS_UP
